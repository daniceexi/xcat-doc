<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
Table of Contents

- [Internal Code Changes of xCAT](#internal-code-changes-of-xcat)
  - [Schema.pm](#schemapm)
  - ["genimage" command](#genimage-command)
  - [anaconda.pm / sles.pm](#anacondapm--slespm)
  - [Postscript **enablekdump**](#postscript-enablekdump)
    - [Workaround for RHEL6](#workaround-for-rhel6)
    - [Workaround for SLES11](#workaround-for-sles11)
    - [Questions](#questions)
  - [Source Files involved](#source-files-involved)
- [Other Design Considerations](#other-design-considerations)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

{{:Design Warning}} 


## Internal Code Changes of xCAT

The following sections are for the internal code changes. 

### Schema.pm

Put the _dump_ attribute to the _linuximage_ schema. The user can use the **chdef** command to set/change the _dump_ attribute for the image. 

### "genimage" command

Disable the kdump service by default. 
    
     chroot $rootimg_dir chkconfig kdump off
    

Create one fake command (**fsck.nfs**) which always return _true_, if "fsck.nfs" doesn't exist in the root image. 

### anaconda.pm / sles.pm

Update code for 
    
     nodeset &lt;nr&gt; osimage=&lt;imgname&gt;
    

or 
    
     nodeset &lt;nr&gt; netboot/statelite
    

If the _dump_ attribute is set for the corresponding image, then put the kernel parameter 
    
     crashkernel=128M@32M
    

to the boot config file. For the platforms using "yaboot", the config file is 
    
     /tftpboot/etc/&lt;nodename&gt;
    

, and then append another kernel parameter 
    
     dump=&lt;dump value&gt;
    

### Postscript **enablekdump**

When the node is booting up, The _enablekdump_ postscipt is used to start the kdump service; for RHEL6, it also do some workaround to generate the initial ramdisk for kdump. In the _enablekdump_ postscript, **/proc/kcmdline** will be parsed, if _dump=_ is found, its value will be parsed, and update the "/etc/kdump.conf" file. After the _/etc/kdump.conf_ file is updated, the _kdump_ service should be started by calling the command: 
    
     /etc/init.d/kdump start
    

For SLES11, it alse need workaround to generate the inital ramdisk for kdump. In the _enablekdump_ postscript, **/proc/kcmdline** will be parsed, if _dump=_ is found, its value will be parsed, and update the "/etc/sysconfig/kdump" file. After the "/etc/sysconfig/kdump" file is updated, the _kdump_ service should be started by calling the command: 
    
     /etc/init.d/boot.kdumpstart
    

  


#### Workaround for RHEL6

Before _kdump_ service is started the NFS directory is mounted to the **/var/tmp** which is used as a temp directory for the _mkdumprd_ command to generate the intial ramdisk for kdump. The NFS directory is read-writeable. The **$xcatmaster:/install/kdump/tmp** will be created when the _xCAT_ package is installed, since the _/install_ directory is exported by default, the **$xcatmaster:/install/kdump/tmp** directory is read-writeable, too. After the _kdump_ service is started successfully, this NFS directory will be umounted from the **/var/tmp** directory, so this workaround won't affect the running of the node. 

For rhels6.1 the _kdump_ service needs _/tmp_ instead of _/var/tmp_ for this workaround. 

The _link_delay = 180_ is added to the _/etc/kdump.conf_ in the _enablekdump_ postscript. Some network cards take a long time to initialize, and some spanning tree enabled networks do not transmit user traffic for long periods after a link state changes. This optional parameter defines a wait period after a link is activated in which the initramfs will wait before attempting to transmit user data. 

#### Workaround for SLES11

On SLES the _boot.kdump service_ is configured via _/etc/sysconfig/kdump_ file. The boot.kdump under _/etc/init.d_ will call mkdumprd -K "$kdump_kernel" -I "$kdump_initrd" -q to create the initrd(call it kdumpinit) which will be used by the kdump. The mkdumprd will call /sbin/mkinitrd to create the kdumpinit. (the mkinitrd only work for diskfull install, it did not consider the diskless install scenario). The /sbin/mkinitrd runs all of the shell script under /lib/mkinitrd/setup to generate the kdumpinit(will pack all scripts under /lib/mkinitrd/boot into the kdumpinit). To simulate a crash do: 
    
      echo 1 &gt; /proc/sys/kernel/sysrqÂ ; echo c &gt; /proc/sysrq-trigger
    

The kdumpinit generated by /sbin/mkinitrd contains all shell scripts under /lib/mkinitrd/boot. All these scripts will be found in the init. There are two special scripts 83-mount.sh and 84-remount.sh. 83-mount.sh is used to mount and check the root device, 84-remount.sh is used to mount the root file system and run the init under the root file system instead of the normal init binary. This is the reason of this problem. For a diskless install server, the root file system is tmpfs and there is no corresponding device, so the hanging error will appear when running 83-mount.sh. If dumping to a remote server, the root file system is useless, only initrd is enough. There is no need to pack these two scripts into the initrd. The around is change these two script names to avoid packing into the initrd. When the initrd created the names are changed back. There is no root device discovering and checking progress so the script 91-kdump.sh can run correctly and the dump is successful. 

#### Questions

For hirarchical diskless environment, the _/install_ directory of the Service Node is mounted from the Management Node. When the node is starting up, the **$xcatmaster:/install/kdump/tmp** directory cannot be mounted because NFS denies re-mount action. How can we do for such a scenario? 

### Source Files involved

     xCAT/xCAT.spec 
     perl-xCAT/xCAT/Schema.pm 
     xCAT-server/share/xcat/netboot/rh/genimage 
     xCAT-server/share/xcat/netboot/add-on/statelite/rc.statelite 
     xCAT-server/lib/xcat/plugins/anaconda.pm 
     xCAT-server/lib/xcat/plugins/sles.pm 
     xCAT/postscripts/enablekdump 

## Other Design Considerations

  * Required reviewers: Bruce Potter 
  * Required approvers: Bruce Potter 
  * Database schema changes: N/A 
  * Affect on other components: N/A 
  * External interface changes, documentation, and usability issues: N/A 
  * Packaging, installation, dependencies: N/A 
  * Portability and platforms (HW/SW) supported: N/A 
  * Performance and scaling considerations: N/A 
  * Migration and coexistence: N/A 
  * Serviceability: N/A 
  * Security: N/A 
  * NLS and accessibility: N/A 
  * Invention protection: N/A 
