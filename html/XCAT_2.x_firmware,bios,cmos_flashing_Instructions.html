<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#xcat-and-remote-flashing-history">xCAT and remote flashing history</a></li>
<li><a href="#remote-flashing">Remote Flashing</a><ul>
<li><a href="#get-flash-code">1. Get Flash Code</a></li>
<li><a href="#extract-files">2. Extract Files</a></li>
<li><a href="#get-libraries">3. Get Libraries</a></li>
<li><a href="#the-secret-or-the-theory-of-how-this-works">3.5 The Secret, or the theory of how this works</a></li>
<li><a href="#create-ls22.tgz-and-runme.sh">4. Create ls22.tgz and runme.sh</a></li>
<li><a href="#deploy-image">5. Deploy image</a></li>
</ul></li>
</ul>
</div>
<p><!-- START doctoc generated TOC please keep comment here to allow auto update --> <!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --> Table of Contents</p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#xcat-and-remote-flashing-history">xCAT and remote flashing history</a></li>
<li><a href="#remote-flashing">Remote Flashing</a></li>
<li><a href="#1%5C-get-flash-code">1. Get Flash Code</a></li>
<li><a href="#2%5C-extract-files">2. Extract Files</a></li>
<li><a href="#3%5C-get-libraries">3. Get Libraries</a></li>
<li><a href="#35-the-secret-or-the-theory-of-how-this-works">3.5 The Secret, or the theory of how this works</a></li>
<li><a href="#4%5C-create-ls22tgz-and-runmesh">4. Create ls22.tgz and runme.sh</a></li>
<li><a href="#5%5C-deploy-image">5. Deploy image</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<p><a href="Howto_Warning">Howto_Warning</a></p>
<p>For an alternative method for flashing firmware, see also [Updating_Firmware_with_Bootable_Media_Creator].</p>
<h2 id="intro"><a href="#TOC">Intro</a></h2>
<p>'Flashing' in the context of this HOWTO is the act of updating a BIOS or some firmware in a node on a cluster. For example, if the vendor supplies you a brand new machine but you then check their website and see that the BIOS is out of date (they post 1.40 but you have 1.38 on your machine) then you may need to update it. The reasons for this update are that there may some fix that may affect the performance of your cluster. In the x86 world this is unfortunately pretty routine. And with the advent of blades and other such systems merged into a machine its not just the BIOS that may need to be updated. On IBM machines you may need to update the BMC. On other vendors machines perhaps its the on board lights out board. Regardless, flashing needs to be done and the way most vendors have it set up does not take into account that a person may have thousands of machines to do this to.</p>
<h2 id="xcat-and-remote-flashing-history"><a href="#TOC">xCAT and remote flashing history</a></h2>
<p>xCAT has a history of using remote flashing to update machines. This has saved administrators countless hours in taking a CD to every machine and rebooting it and toggling though menus. In xCAT 1.3 a method was introduced that used the memdisk abilities of pxelinux to boot into a DOS mode and execute DOS images that IBM provided. This method was extremely difficult to set up, but once working was very reliable and worked very nicely. I once did 1500 nodes in less than an hour with it. (It could have been done faster but I was being cautious). The method was documented <a href="http://xcat.org/doc/1.x/flash-HOWTO.html">here</a></p>
<p>With xCAT 2, we have found that many vendors, including IBM, now support a Linux binary executable that can flash subsystems via the command line. There are also others that support setting the BIOS CMOS settings. This was a very welcomed event. As such, when xCAT 2 was written the remote flash (rflash) command seemed low on the priorities to move from 1.3 to 2.x. This is because the rflash method most used was a DOS image and I don't know of many others who used different images. So the state of xCAT 2.x today is that it does indeed support remote flashing with Linux images. However, to date the DOS based rflash does not exist.</p>
<p>The rest of this article outlines how to do the Linux based remote flash with xCAT 2</p>
<h2 id="remote-flashing"><a href="#TOC">Remote Flashing</a></h2>
<p>Our example here is an LS22. This example is taken from the mailing list comment Egan made <a href="http://www.xcat.org/pipermail/xcat-user/2008-November/007310.html">here</a></p>
<h3 id="get-flash-code"><a href="#TOC">1. Get Flash Code</a></h3>
<p>For My IBM LS22 this was an exercise in patience navigating ibm.com. The files I found were:<br />ibm_fw_bios_l8e131a_linux_amd32.bin<br />ibm_fw_bmc_l8bt14a_linux_i386.bin<br />ibm_fw_mptsas_ls22-ls42-2.50_linux_32-64.bin</p>
<p>I placed all of these files in /tmp/ls22</p>
<pre><code>cd /tmp/ls22
chmod 755 ibm*sh</code></pre>
<h3 id="extract-files"><a href="#TOC">2. Extract Files</a></h3>
<pre><code>mkdir bios bmc mptsas
cd bios
../ibm_fw_bios_18e131a_linux_amd32.bin -x .
cd ../bmc
../ibm_fw_bmc_18bt14a_linux_i386.bin -x .
cd ../mptsas
../ibm_fw_mptsas_ls22-ls42-2.50_linux_32-64.bin -x .
cd ..</code></pre>
<p>The commands were from the various readmes. There were some issues I ran into at a few points:<br />a. The files were corrupted so they didn't extract right, at which I found after some debugging that redownloading solved my problems.<br />b. The -x option really only works on the current directory... at least that's how it was for me. So no doing: -x /tmp/foo/, only -x .</p>
<h3 id="get-libraries"><a href="#TOC">3. Get Libraries</a></h3>
<p>Up to this point I've been doing everything on a RedHat 5.2 machine that was not an LS22. In order for the lflash64 commands to work that were just extracted above, you have to make sure you have libraries so they can execute. If you noticed Egan's email he showed you could run:</p>
<pre><code>ldd lflash64</code></pre>
<p>To show what files to copy. I did this and found that I needed to do the following:</p>
<pre><code>cd /tmp/ls22
mkdir lib
cp /lib64/libc.so.6 .
cp /lib64/libdl.so.2 .
cp /lib64/libm.so.6 .
cp /usr/lib64/libz.so.1 .
cp /lib64/ld-linux-x86-64.so.2 .</code></pre>
<p>After this I just copied the libraries to all subdirectories since they all needed it. (I'm sure you could make only one link somewhere but I was trying to get it done fast)</p>
<pre><code>cp -a lib/* bios/
cp -a lib/* bmc/
cp -a lib/* mptsas/</code></pre>
<p>Now we create the runme.sh script.</p>
<h3 id="the-secret-or-the-theory-of-how-this-works"><a href="#TOC">3.5 The Secret, or the theory of how this works</a></h3>
<p>It turns out that xCAT has an undocumented feature (well I guess its documented now that I'm writing about it) that you can use the nodeset command to wget a remote image and then it is hard coded to untar the image, extract it into /tmp/&lt;image nam&gt; and then run the runme.sh command.</p>
<p>So for example:<br />- Create a directory called junk<br />- Put what ever you want in it, including a file called runme.sh<br />- tar up the file and call it junk.tgz<br />- put it on any web server that a node can get to.<br />Then run:</p>
<pre><code>nodeset &amp;lt;node&amp;gt; runimage=http://</code></pre>
<p>Then reboot the node.<br />If you do that then xCAT will untar junk.tgz on the node in the directory /tmp/junk.tgz/ and then run runme.sh</p>
<h3 id="create-ls22.tgz-and-runme.sh"><a href="#TOC">4. Create ls22.tgz and runme.sh</a></h3>
<p>So, following what we know in 3.5, we now create the runme.sh.</p>
<pre><code>cd /tmp/ls22</code></pre>
<p>Create runme.sh, the contents look like this:</p>
<pre><code>#!/bin/sh
cd bios
./runme.sh
cd ../bmc
./runme.sh
cd ../mptsas
./runme.sh
cd ../cmos
./runme.sh</code></pre>
<p>Now create the runme for the different subsystems:<br /><strong>BIOS</strong></p>
<pre><code>cd bios
cat runme.sh
#!/bin/sh
LD_LIBRARY_PATH=. ./ld-linux-x86-64.so.2 ./lflash64</code></pre>
<p>MPTSAS and BMC: Do the exact same thing.<br /><strong>CMOS</strong><br />This one you need the ASU tool for (as well as libpthread.so.0)<br />runme.sh looks like this:</p>
<pre><code>LD_LIBRARY_PATH=. ./ld-linux-x86-64.so.2 ./asu64 batch ls22-cmos.batch</code></pre>
<p>ls22-cmos.batch is a file I created that looks like this:</p>
<pre><code>loaddefault all
set CMOS_SerialA &quot;Auto-Configure&quot;
set CMOS_SerialB &quot;Auto-Configure&quot;
set CMOS_RemoteConsoleEnable &quot;Enabled&quot;
set CMOS_RemoteConsoleComPort &quot;COM 2&quot;
set CMOS_RemoteConsoleEmulation &quot;VT100/VT220&quot;
set CMOS_RemoteConsoleKybdEmul &quot;VT100/VT220&quot;
set CMOS_RemoteConsoleBootEnable &quot;Enabled&quot;
set CMOS_RemoteConsoleFlowCtrl &quot;Hardware&quot;
set CMOS_ENET2_PXE_ENABLE &quot;Disabled&quot;
set CMOS_ENET3_PXE_ENABLE &quot;Disabled&quot;
set CMOS_ENET4_PXE_ENABLE &quot;Disabled&quot;
set CMOS_PostBootFailRequired &quot;Disabled&quot;
set CMOS_ROMControlSlot1 &quot;Disabled&quot;
set CMOS_ROMControlSlot2 &quot;Disabled&quot;
set CMOS_IOMMU_PLANAR_ENABLE &quot;Enabled&quot;</code></pre>
<p>Ok, now that you're done you have a file structure that looks like this:</p>
<pre><code>/tmp/ls22
|-- bios
|   |-- 0078000.FLS
|   |-- CMOSDEF.BIN
|   |-- CPUTHROT.BIN
|   |-- ISCSIROM.BIN
|   |-- PXEROM.BIN
|   |-- ld-linux-x86-64.so.2
|   |-- lflash
|   |-- lflash64
|   |-- libc.so.6
|   |-- libdl.so.2
|   |-- libm.so.6
|   |-- libz.so.1
|   |-- readme.lin
|   |-- runFlash.sh
|   `-- runme.sh
|-- bmc
|   |-- FULLFW.MOT
|   |-- ld-linux-x86-64.so.2
|   |-- lflash
|   |-- lflash64
|   |-- libc.so.6
|   |-- libdl.so.2
|   |-- libm.so.6
|   |-- libz.so.1
|   |-- readme.lin
|   `-- runme.sh
|-- cmos
|   |-- asu64
|   |-- ld-linux-x86-64.so.2
|   |-- libc.so.6
|   |-- libdl.so.2
|   |-- libm.so.6
|   |-- libpthread.so.0
|   |-- librt.so.1
|   |-- ls22-cmos.batch
|   `-- runme.sh
|-- mptsas
|   |-- FULLFW.MOT
|   |-- ld-linux-x86-64.so.2
|   |-- lflash
|   |-- lflash64
|   |-- libc.so.6
|   |-- libdl.so.2
|   |-- libm.so.6
|   |-- libz.so.1
|   |-- readme.lin
|   `-- runme.sh
`-- runme.sh</code></pre>
<h3 id="deploy-image"><a href="#TOC">5. Deploy image</a></h3>
<p>Now you just need to tar it up. In our example, we'll put it in /install/flash/ls22.tgz:</p>
<pre><code>cd /tmp/ls22/
tar czvf ../ls22.tgz .
mv ../ls22.tgz /install/flash/</code></pre>
<p>Now we're ready to install the node. In this case my node is called b001:</p>
<pre><code>nodeset b001 runimage=http://192.168.15.1/install/flash/x3455.tgz
rpower b001 boot</code></pre>
<p>Now we'll test on this node and make sure everything worked. If it did, you'll see all the subsystems flash.</p>
<p>Nice job! Now get some work done.</p>
</body>
</html>
