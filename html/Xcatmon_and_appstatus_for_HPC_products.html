<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#checking-methods-for-hpc-application-status">Checking methods for HPC application status</a></li>
<li><a href="#pull-model-implementation">Pull model implementation</a></li>
<li><a href="#push-model-implementation">Push model implementation</a></li>
</ul>
</div>
<p><!-- START doctoc generated TOC please keep comment here to allow auto update --> <!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --> Table of Contents</p>
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#checking-methods-for-hpc-application-status">Checking methods for HPC application status</a></li>
<li><a href="#pull-model-implementation">Pull model implementation</a></li>
<li><a href="#push-model-implementation">Push model implementation</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<p>{{:Design Warning}}</p>
<h2 id="summary"><a href="#TOC">Summary</a></h2>
<p>This LI is used to monitor the HPC product status, we support two models:</p>
<p>1.    Pull models:</p>
<p>Using the existing xcatmon mechanism, it will provide ongoing status of the applications, and customers will probably want to set something like a 5 minute polling interval. The status checking result will be presented in the node attribute &quot;appstatus&quot;.</p>
<p>2.    Push models:</p>
<p>Writing a new postscript called &quot;HPCbootstatus&quot;, it will check the initial appstatus when nodes first boot and report the appstatus to xcatd daemon on xCAT Management Node. We call it &quot;push&quot; model so that we could see the initial status immediately.</p>
<p>To run the status query script every time the node boots, we should specify &quot;HPCbootstatus&quot; in the node attribute &quot;postscripts&quot; if we need this monitor function. For diskfull nodes, this postscript will set up an entry in /etc/init.d or /etc/inittab to make sure it's run in the sequent reboot after the installation.</p>
<p>It's not enough to just set HPCbootstatus as the last postscript, because the app startup may be slow, so when our HPCbootstatus script is running, the app might not complete the start yet. So we plan to use a loop/sleep to query the app status in HPCbootstatus script, and set a timeout value (e.g. 5 mins) for waiting. If in this time period, once we get the status for a certain application, we will report to xcatd, instead of waiting for all status ready to report, this can let the user know app status in time.</p>
<h2 id="symbols"><a href="#TOC">Symbols</a></h2>
<p>The status of applications will be presented as the format &quot;&lt;keyword&gt;=&lt;value&gt;&quot; in node attribute &quot;appstatus&quot;, the users can customarize the &lt;keyword&gt; and the &lt;value&gt; as they want. Change xcatmon configuration or monsetting table to customerize the &lt;keyword&gt;, change the output of &quot;cmd&quot;/&quot;dcmd&quot; script to customerize the &lt;value&gt;.</p>
<p>Here is an example for your reference.</p>
<p>Product keyword value</p>
<p>GPFS gpfs-mmfsd up/down</p>
<p>gpfs-quorum Quorum = 1, Quorum achieved</p>
<p>gpfs-filesystem /gpfs1,/gpfs2</p>
<p>LoadLeveler loadl-schedd 1!Avail  (&lt;Availability&gt;!&lt;State&gt;)</p>
<p>loadl-startd 1!Idle  (&lt;Availability&gt;!&lt;State&gt;)</p>
<p>LAPI lapi-pnsd active/inoperative</p>
<p> </p>
<h2 id="checking-methods-for-hpc-application-status"><a href="#TOC">Checking methods for HPC application status</a></h2>
<p>I plan to use &quot;port&quot;, &quot;lcmd=xxx&quot; and &quot;dcmd=xxx&quot; to check the node appstatus via xcatmon, based on the calls provided by GPFS, LAPI and Loadleveler teams.</p>
<p>Here is an example of xcatmon/monsetting configuration and status calls:</p>
<p>Product keyword monsetting table status calls</p>
<p>GPFS gpfs-mmfsd port=1191,group=compute n/a, use the existing logic.</p>
<p>gpfs-quorum lcmd=/xcat/xcatmon/gpfs-quorum /usr/lpp/mmfs/bin/mmgetstate -s&amp;#124;grep achieved</p>
<p>gpfs-filesystem lcmd=/xcat/xcatmon/gpfs-filesystem /usr/lpp/mmfs/bin/mmlsmount all -L</p>
<p>LoadLeveler loadl-schedd lcmd=/xcat/xcatmon/loadl-schedd llrstatus -r %sca %scs</p>
<p>loadl-startd lcmd=/xcat/xcatmon/loadl-startd llrstatus -r %sta %sts</p>
<p>LAPI lapi-pnsd dcmd=/xcat/xcatmon/lapi-pnsd,group=compute lssrc -s pnsd</p>
<p> </p>
<h2 id="pull-model-implementation"><a href="#TOC">Pull model implementation</a></h2>
<p>To support the &quot;pull&quot; model, we need to update xCAT2-Monitoring.pdf and give some examples about how to set up xCAT monsetting table to monitor the status of HPC applications, including the status calls listed in the table above.</p>
<p>Since the calls is very simple, so I think we do not need to ship these sample scripts (e.g. /xcat/xcatmon/loadl-schedd, etc) in xCAT packages, we can write them in xCAT2-Monitoring documentation as a simple example so that the user can get sense of how we use it.</p>
<p>No code change is needed for &quot;pull&quot; support.</p>
<h2 id="push-model-implementation"><a href="#TOC">Push model implementation</a></h2>
<p>To support the &quot;push&quot; model, we need to write a new postscript called &quot;HPCbootstatus&quot; to check the initial application status when the node first boots. That is the last script to run which runs local commands to query each application's status. Query in the order listed above, since each application is dependent on the previous one running correctly.</p>
<p>In this script, after we get the application's status locally, we need to do communication with xcatd on MN to update xCAT Database. For AIX, we can use a similar subroutine as &quot;updateflag&quot; in &quot;xcataixpost&quot; script to report the status, e.g. &quot;hpcbootstatus $state&quot;; For Linux, we can call &quot;updateflag.awk&quot; to report the status. 1</p>
<p><strong>(1)</strong> I found xcat does not use &quot;updateflag.awk&quot; in AIX logic, and I did a quick test to use &quot;updateflag.awk&quot; on AIX to try to communicate with xcatd on MN, it failed. So I am thinking maybe there is some difference about awk support between Linux and AIX. I will follow the existing logic on AIX to report the initial status, that is something like &quot;updateflag&quot; subroutine.</p>
<p>We need to develope two sub-scripts, such as HPCbootstatus.aix and HPCbootstatus.linux. Because on Linux, the postscript should be written in shell and call updateflag.awk to report appstatus to xcatd., While on AIX, we have to write HPCbootstatus.aix in Perl since it should call Perl module &quot;IO::Socket::INET&quot; to updateflags to xcatd on MN. We will release a unique postscript &quot;HPCbootstatus&quot; to our users, and in this script, we will call HPCbootstatus.aix or HPCbootstatus.linux depends on its uname.</p>
<p>In xcatd, we need to add a new case when handling &quot;<span class="math">$text&quot; message, that is &quot;elsif ($</span>text =~ /hpcbootstatus/)&quot;, then call $tab-&gt;setNodeAttribs to update &quot;appstatus&quot; column of the nodelist table with the new node appstatus. At the sametime, we need to make sure to also update the appstatustime attribute, too.</p>
<p>Beside, in this script, we need to add an entry in /etc/init.d or /etc/inittab to make sure it's run in the sequent reboot after the installation.</p>
<p>The &quot;push&quot; model will not depend on Ling's condition-response mechanism, only depends on xcatd daemon, it looks more flexible.</p>
<p>If the administrator configures both pull model and push model, then we can accept the overlap.</p>
</body>
</html>
